// File automatically generated by swift-bridge.
#include <stdbool.h>
typedef struct RustApp RustApp;
void __swift_bridge__$RustApp$_free(void* self);

void* __swift_bridge__$Vec_RustApp$new(void);
void __swift_bridge__$Vec_RustApp$drop(void* vec_ptr);
void __swift_bridge__$Vec_RustApp$push(void* vec_ptr, void* item_ptr);
void* __swift_bridge__$Vec_RustApp$pop(void* vec_ptr);
void* __swift_bridge__$Vec_RustApp$get(void* vec_ptr, uintptr_t index);
void* __swift_bridge__$Vec_RustApp$get_mut(void* vec_ptr, uintptr_t index);
uintptr_t __swift_bridge__$Vec_RustApp$len(void* vec_ptr);
void* __swift_bridge__$Vec_RustApp$as_ptr(void* vec_ptr);

typedef struct __swift_bridge__$MessageWrapper { void* message; } __swift_bridge__$MessageWrapper;
typedef struct __swift_bridge__$Option$MessageWrapper { bool is_some; __swift_bridge__$MessageWrapper val; } __swift_bridge__$Option$MessageWrapper;
typedef struct __swift_bridge__$ParserOptions { bool ignore_tag; bool requires_other_clause; bool should_parse_skeletons; bool capture_location; void* locale; } __swift_bridge__$ParserOptions;
typedef struct __swift_bridge__$Option$ParserOptions { bool is_some; __swift_bridge__$ParserOptions val; } __swift_bridge__$Option$ParserOptions;
void* __swift_bridge__$RustApp$new(void);
void* __swift_bridge__$RustApp$icu_message_format(void* self, struct __swift_bridge__$MessageWrapper message_wrapper, struct __swift_bridge__$ParserOptions options);


